
struct Solution;

impl Solution {
    pub fn generate_parenthesis(n: i32) -> Vec<String> {
        let mut parens = vec![];
        Self::builder("(".into(), 1, 0, n as u8, &mut parens);
        parens
    }

    fn builder(mut base: String, left: u8, right: u8, n: u8, parens: &mut Vec<String>) {
        match (left,right) {
            (a,b) if a==n && b==n => parens.push(base),
            (a,_) if a == n => {
                base.push(')');
                Self::builder(base, left, right+1, n, parens)
            },
            (a,b) if b <= a => {
                let mut base2 = base.clone();
                base2.push('(');
                base.push(')');
                Self::builder(base2, left+1, right, n, parens);
                Self::builder(base, left, right+1, n, parens);
            },
            _ => (),
        }
    }
}

fn main() {
    let tests = [
        (1, vec!["()"]), // 1
        (2, vec!["(())", "()()"]), // 2
        (3, vec!["((()))", "(()())", "(())()", "()(())", "()()()"]), // 5
        // (4, vec!["(((())))","((()()))","((())())","((()))()","(()(()))","(()()())","(()())()","(())(())","(())()()","()((()))","()(()())","()(())()","()()(())","()()()()"]), // 14
        // (5, vec!["((((()))))","(((()())))","(((())()))","(((()))())","(((())))()","((()(())))","((()()()))","((()())())","((()()))()","((())(()))","((())()())","((())())()","((()))(())","((()))()()","(()((())))","(()(()()))","(()(())())","(()(()))()","(()()(()))","(()()()())","(()()())()","(()())(())","(()())()()","(())((()))","(())(()())","(())(())()","(())()(())","(())()()()","()(((())))","()((()()))","()((())())","()((()))()","()(()(()))","()(()()())","()(()())()","()(())(())","()(())()()","()()((()))","()()(()())","()()(())()","()()()(())","()()()()()"]), // 42
    ];

    for (i,t) in tests.into_iter().enumerate() {
        let result = Solution::generate_parenthesis(t.0);
        let eval = if result == t.1 {('âœ”', true)} else {('âœ˜', false)};
        let expected = if eval.1 {"".to_string()} else { format!("=> Expected: {:?}", t.1) };
        println!("{}.[{}] {:?} {}", i+1, eval.0, result, expected);
    }

    println!("\nJob done!");
}

/*
=================================( 1 )

()

=================================( 2 )

()()

(()) -> (P1)

=================================( 3 )

()()()

(())() ()(()) 

( (()) ) ( ()() ) -> (P2)

=================================( 4 )

()()()()

(())()() ()(())() ()()(())
(())(())

((()))() (()())() 
()((())) ()(()())  

( (()()) ) ( (())() ) ( ()(()) ) ( ()()() ) ( ((())) )  -> (P3)

==================================( 5 )

()()()()()

(())()()() ()(())()() ()()(())() ()()()(())   -> (P1)()()() ()(P1)()() ()()(P1)() ()()()(P1)
(())(())() (())()(()) ()(())(())              -> (P1)(P1)() (P1)()(P1) ()(P1)(P1)

((()))()() (()())()() -> (P2)()()
((()))(()) (()())(()) -> (P2)(P1) __  -> (P2)P2
()((()))() ()(()())() -> ()(P2)()     -> ()(P2)()
()()((())) ()()(()()) -> ()()(P2)
(())((())) (())(()()) -> (P1)(P2) __  -> P2(P2)

(((())))() ((()()))() ((())())() (()(()))() (()()())() -> (P3)()
()(((()))) ()((()())) ()(()()()) ()((())()) ()(()(())) -> ()(P3)

(()()()()) (()()(())) (()(())()) (()(()())) (()((()))) ((())()()) ((())(())) ((()())()) ((()()())) ((()(()))) (((()))()) (((())())) (((()()))) ((((()))))  -> (P4)

==================================

*/